test_load:
  -
    id: value
    app:
      > class MyApp:
      >   x = byoc.param(Value(1))
    expected:
      x: 1
  -
    id: value-meta
    app:
      > class MyApp(MetaMixin):
      >   x = byoc.param(Value(1))
    expected:
      x: 1
      meta.x.file: '<string>'
      meta.x.line: 2
  -
    id: func
    app:
      > class MyApp:
      >   x = byoc.param(Func(list))
    expected:
      x: []
  -
    id: method
    app:
      > class MyApp:
      >
      >   def calc_x(self):
      >       return 1
      >
      >   x = byoc.param(Method(calc_x))

    expected:
      x: 1
  -
    id: method-meta
    app:
      > class MyApp(MetaMixin):
      >
      >   def calc_x(self):
      >       return 1
      >
      >   x = byoc.param(Method(calc_x))

    expected:
      x: 1
      meta.x.file: '<string>'
      meta.x.line: 6
  -
    id: key
    app:
      > class MyApp:
      >
      >   @byoc.configs
      >   def iter_configs(self):
      >       yield DictConfig({'x': 1})
      >
      >   x = byoc.param(Key(DictConfig, 'x'))

    expected:
      x: 1
  -
    id: key-callable
    app:
      > from operator import itemgetter
      >
      > class MyApp:
      >
      >   @byoc.configs
      >   def iter_configs(self):
      >       yield DictConfig({'x': 1})
      >
      >   x = byoc.param(Key(DictConfig, itemgetter('x')))

    expected:
      x: 1
  -
    id: key-iterable
    app:
      > class MyApp:
      >
      >   @byoc.configs
      >   def iter_configs(self):
      >       yield DictConfig({'x': {'y': 1}})
      >
      >   xy = byoc.param(Key(DictConfig, ['x', 'y']))

    expected:
      xy: 1
  -
    id: key-apply
    app:
      > class MyApp:
      >
      >   @byoc.configs
      >   def iter_configs(self):
      >       yield DictConfig({'x': '1'})
      >
      >   x = byoc.param(Key(DictConfig, 'x', apply=int))

    expected:
      x: 1
  -
    id: key-order
    app:
      > class MyConfigA(DictConfig):
      >   pass
      >
      > class MyConfigB(DictConfig):
      >   pass
      >
      > class MyApp:
      >
      >   @byoc.configs
      >   def iter_configs(self):
      >       yield MyConfigA({'x': 1})
      >       yield MyConfigB({'x': 2})
      >
      >   x1 = byoc.param(
      >       Key(MyConfigA, 'x'),
      >       Key(MyConfigB, 'x'),
      >   )
      >   x2 = byoc.param(
      >       Key(MyConfigB, 'x'),
      >       Key(MyConfigA, 'x'),
      >   )

    expected:
      x1: 1
      x2: 2
  -
    id: key-match-config-class
    app:
      > class MyConfigA(DictConfig):
      >   pass
      >
      > class MyConfigB(DictConfig):
      >   pass
      >
      > class MyApp:
      >
      >   @byoc.configs
      >   def iter_configs(self):
      >       yield MyConfigA({'x': 1})
      >       yield MyConfigB({'x': 2})
      >
      >   x = byoc.param(Key(DictConfig, 'x'), pick=list)
      >   y = byoc.param(Key(MyConfigA, 'x'), pick=list)
      >   z = byoc.param(Key(MyConfigB, 'x'), pick=list)

    expected:
      x: [1, 2]
      y: [1]
      z: [2]
  -
    id: key-skip-missing
    app:
      > class MyApp:
      >
      >   @byoc.configs
      >   def iter_configs(self):
      >       yield DictConfig({'x2': 1})
      >
      >   x = byoc.param(
      >       Key(DictConfig, 'x1'),
      >       Key(DictConfig, 'x2'),
      >   )

    expected:
      x: 1
  -
    id: key-no-value-found
    app:
      > class MyApp:
      >
      >   @byoc.configs
      >   def iter_configs(self):
      >       yield DictConfig({})
      >
      >   x = byoc.param(
      >       Key(DictConfig, 'x'),
      >   )

    error:
      type: NoValueFound
      message: no value found for <param MyApp.x>
  -
    id: key-meta
    app:
      > class MyConfig(byoc.Config):
      >
      >     def iter_finders(self):
      >         yield byoc.DictFinder(
      >             values={'x': 1},
      >             meta=2,
      >         )
      >
      > class MyApp(MetaMixin):
      >
      >   @byoc.configs
      >   def iter_configs(self):
      >       yield MyConfig()
      >
      >   x = byoc.param(Key(MyConfig, 'x'))

    expected:
      x: 1
      meta.x: 2
  -
    id: key-meta-lookup
    app:
      > class MyConfig(byoc.Config):
      >
      >     def iter_finders(self):
      >         yield byoc.DictFinder(
      >             values={'x': 1},
      >             meta={'x': 2},
      >             lookup_meta=True,
      >         )
      >
      > class MyApp(MetaMixin):
      >
      >   @byoc.configs
      >   def iter_configs(self):
      >       yield MyConfig()
      >
      >   x = byoc.param(Key(MyConfig, 'x'))

    expected:
      x: 1
      meta.x: 2
  -
    id: key-schema
    app:
      > def plus_1(d):
      >     return {k: v + 1 for k, v in d.items()}
      >
      > class MyConfig(byoc.Config):
      >
      >     def iter_finders(self):
      >         yield byoc.DictFinder({'x': 1}, schema=plus_1)
      >
      > class MyApp:
      >
      >   @byoc.configs
      >   def iter_configs(self):
      >       yield MyConfig()
      >
      >   x = byoc.param(Key(MyConfig, 'x'))

    expected:
      x: 2
  -
    id: key-schema-meta-lookup
    app:
      > def my_schema(values, meta):
      >      meta_out = strip_keys(meta)
      >      meta.clear()
      >      meta.update(meta_out)
      >      return strip_keys(values)
      >
      > def strip_keys(d):
      >     return {k[0]: v for k, v in d.items()}
      >
      > class MyConfig(byoc.Config):
      >
      >     def iter_finders(self):
      >         yield byoc.DictFinder(
      >             values={'x-verbose': 1},
      >             meta={'x-verbose': 2},
      >             schema=my_schema,
      >             lookup_meta=True,
      >         )
      >
      > class MyApp(MetaMixin):
      >
      >   @byoc.configs
      >   def iter_configs(self):
      >       yield MyConfig()
      >
      >   x = byoc.param(Key(MyConfig, 'x'))

    expected:
      x: 1
      meta.x: 2
  -
    id: key-root
    app:
      > class MyConfig(byoc.Config):
      >
      >     def iter_finders(self):
      >         yield byoc.DictFinder(
      >             values={'x': {'y': 1}},
      >             root_key='x',
      >         )
      >
      > class MyApp:
      >
      >   @byoc.configs
      >   def iter_configs(self):
      >       yield MyConfig()
      >
      >   y = byoc.param(Key(MyConfig, 'y'))

    expected:
      y: 1
  -
    id: key-root-missing
    app:
      > class MyConfig(byoc.Config):
      >
      >     def iter_finders(self):
      >         yield byoc.DictFinder(
      >             values={'x': {'y': 1}},
      >             root_key='z',
      >         )
      >
      > class MyApp:
      >
      >   @byoc.configs
      >   def iter_configs(self):
      >       yield MyConfig()
      >
      >   y = byoc.param(Key(MyConfig, 'y'), Value(2))

    expected:
      y: 2
  -
    id: key-root-meta-lookup
    app:
      > class MyConfig(byoc.Config):
      >
      >     def iter_finders(self):
      >         yield byoc.DictFinder(
      >             values={'x': {'y': 1}},
      >             meta={'x': {'y': 2}},
      >             root_key='x',
      >             lookup_meta=True,
      >         )
      >
      > class MyApp(MetaMixin):
      >
      >   @byoc.configs
      >   def iter_configs(self):
      >       yield MyConfig()
      >
      >   y = byoc.param(Key(MyConfig, 'y'))

    expected:
      y: 1
      meta.y: 2
  -
    id: config-attr
    app:
      > class MyConfig(byoc.Config):
      >   
      >   def __init__(self):
      >       self.x = 1
      >
      >   def iter_finders(self):
      >       yield byoc.DictFinder({'y': 2})
      >
      > my_config = MyConfig()
      >
      > class MyApp(MetaMixin):
      >
      >   @byoc.configs
      >   def iter_configs(self):
      >       yield my_config
      >
      >   x = byoc.config_attr(MyConfig)
      >   x_named = byoc.config_attr(MyConfig, 'x')
      >   y = byoc.param(Key(MyConfig, 'y'))

    expected:
      x: 1
      x_named: 1
      y: 2
      meta.x.config: my_config
      meta.x.attr: 'x'
      meta.x_named.config: my_config
      meta.x_named.attr: 'x'
  -
    id: apply
    app:
      > class MyApp:
      >   x = byoc.param(
      >       Value(1),
      >       apply=lambda x: x + 1
      >   )
    expected:
      x: 2
  -
    id: detach
    app:
      > class MyApp:
      >
      >   def __init__(self, x):
      >     self.x = x
      >
      >   def calc_y(self):
      >     return 6 / self.x
      >
      >   y = byoc.param(Method(calc_y))
      >
      > try:
      >   decoy = MyApp(0)
      >   byoc.load(decoy)
      > except ZeroDivisionError:
      >   pass
      >
      > # The fact that a previous instance of `MyApp` failed to load should 
      > # not affect the loading of a new instance.
      > app = MyApp(2)
    expected:
      x: 2
      y: 3
  -
    id: pick-first
    app:
      > class MyApp:
      >   x = byoc.param(
      >       Value(1),
      >       Value(2),
      >   )
    expected:
      x: 1
  -
    id: pick-list
    app:
      > class MyApp:
      >   x = byoc.param(
      >       Value(1),
      >       Value(2),
      >       pick=list,
      >   )
    expected:
      x: [1, 2]
  -
    id: pick-list-meta
    app:
      > class MyApp(MetaMixin):
      >   x = byoc.param(
      >       Value(1),
      >       Value(2),
      >       pick=byoc.list,
      >   )
    expected:
      x: [1, 2]
      meta.x.0.file: '<string>'
      meta.x.0.line: 3
      meta.x.1.file: '<string>'
      meta.x.1.line: 4
  -
    id: pick-merge-dicts
    app:
      > class MyApp:
      >   x = byoc.param(
      >       Value({'a': 1, 'b': 2}),
      >       Value({'a': 3, 'c': 4}),
      >       pick=byoc.merge_dicts,
      >   )
    expected:
      x: {'a': 1, 'b': 2, 'c': 4}
  -
    id: pick-merge-dicts-meta
    app:
      > class MyApp(MetaMixin):
      >   x = byoc.param(
      >       Value({'a': 1, 'b': 2}),
      >       Value({'a': 3, 'c': 4}),
      >       pick=byoc.merge_dicts,
      >   )
    expected:
      x: {'a': 1, 'b': 2, 'c': 4}
      meta.x.a.file: '<string>'
      meta.x.a.line: 3
      meta.x.b.file: '<string>'
      meta.x.b.line: 3
      meta.x.c.file: '<string>'
      meta.x.c.line: 4
  -
    id: pick-apply
    app:
      > def my_pick(xs):
      >   return [x for x in xs if x > 2]
      >
      > class MyApp:
      >   x = byoc.param(
      >       Value(1),
      >       Value(2),
      >       apply=lambda x: x + 1,
      >       pick=my_pick,
      >   )
    expected:
      x: [3]
  -
    id: hidden
    app:
      > class MyApp:
      >   x = byoc.param(Value(1))
      >
      > app = MyApp()
      > app.x = 2
    expected:
      x: 2
  -
    id: inheritance
    app:
      > class MyBase:
      >   x = byoc.param(Value(1))
      >   y = byoc.param(Value(2))
      > class MyApp(MyBase):
      >   y = byoc.param(Value(3))
      >   z = byoc.param(Value(4))
    expected:
      x: 1
      y: 3
      z: 4
  -
    id: inheritance-multi
    app:
      > class MyBaseA:
      >   a = byoc.param(Value(1))
      >   ab = byoc.param(Value(1))
      >   ac = byoc.param(Value(1))
      >   abc = byoc.param(Value(1))
      >
      > class MyBaseB:
      >   b = byoc.param(Value(2))
      >   ab = byoc.param(Value(2))
      >   bc = byoc.param(Value(2))
      >   abc = byoc.param(Value(2))
      >
      > class MyAppC(MyBaseA, MyBaseB):
      >   c = byoc.param(Value(3))
      >   ac = byoc.param(Value(3))
      >   bc = byoc.param(Value(3))
      >   abc = byoc.param(Value(3))
      >
      > app = MyAppC()
      
    expected:
      a: 1
      b: 2
      c: 3

      ab: 1
      ac: 3
      bc: 3

      abc: 3
  -
    id: inheritance-hidden
    app:
      > def do_not_call():
      >   raise NotImplementedError
      >
      > class MyBase:
      >   x = byoc.param(Func(do_not_call))
      >
      > class MyApp(MyBase):
      >   x = 2
    expected:
      x: 2
  -
    id: dependencies-none
    app:
      > class MyApp:
      >   x = byoc.param(Value(1))
      >   y = byoc.param(Value(2))
    expected:
      x: 1
      y: 2
  -
    id: dependencies-in-order
    app:
      > class MyApp:
      >
      >   def calc_y(self):
      >       return self.x + 1
      >
      >   x = byoc.param(Value(1))
      >   y = byoc.param(Method(calc_y))
    expected:
      x: 1
      y: 2
  -
    id: dependencies-out-of-order
    app:
      > class MyApp:
      >
      >   def calc_x(self):
      >       return self.y - 1
      >
      >   x = byoc.param(Method(calc_x))
      >   y = byoc.param(Value(2))
    expected:
      x: 1
      y: 2
  -
    id: dependencies-circular-2
    app:
      > class MyApp:
      >
      >   def calc_x(self):
      >       return self.y
      >
      >   def calc_y(self):
      >       return self.x
      >
      >   x = byoc.param(Method(calc_x))
      >   y = byoc.param(Method(calc_y))
    error:
      type: UsageError
      message:
        - encountered circular dependency
        - <param MyApp.x>
        - <param MyApp.y>
  -
    id: dependencies-circular-3
    app:
      > class MyApp:
      >
      >   def calc_x(self):
      >       return self.y
      >
      >   def calc_y(self):
      >       return self.z
      >
      >   def calc_z(self):
      >       return self.x
      >
      >   x = byoc.param(Method(calc_x))
      >   y = byoc.param(Method(calc_y))
      >   z = byoc.param(Method(calc_z))
    error:
      type: UsageError
      message:
        - encountered circular dependency
        - <param MyApp.x>
        - <param MyApp.y>
        - <param MyApp.z>
  -
    id: recursive
    app:
      > class MyChild:
      >   x = byoc.param(Value(1))
      >
      > class MyApp:
      >   child = byoc.param(
      >       Value(MyChild()),
      >       on_load=byoc.recursive_load,
      >   )
    expected:
      child.x: 1
  -
    id: recursive-list
    app:
      > class MyChild:
      >   x = byoc.param(Value(1))
      >
      > class MyApp:
      >   children = byoc.param(
      >       Value([MyChild(), MyChild()]),
      >       on_load=byoc.recursive_load_from_list,
      >   )
    expected:
      children.0.x: 1
      children.1.x: 1
  -
    id: recursive-dict
    app:
      > class MyChild:
      >   z = byoc.param(Value(1))
      >
      > class MyApp:
      >   children = byoc.param(
      >       Value({'x': MyChild(), 'y': MyChild()}),
      >       on_load=byoc.recursive_load_from_dict_values,
      >   )
    expected:
      children.x.z: 1
      children.y.z: 1
  -
    id: recursive-same-child-two-attrs
    app:
      > class MyChild:
      >   x = byoc.param(Value(1))
      >
      > class MyApp:
      >   child_1 = byoc.param(
      >       Value(MyChild()),
      >       on_load=byoc.recursive_load,
      >   )
      >   child_2 = byoc.param(
      >       Value(MyChild()),
      >       on_load=byoc.recursive_load,
      >   )
    expected:
      child_1.x: 1
      child_2.x: 1
  -
    id: recursive-configs
    app:
      > class MyChild:
      >   y = byoc.param(Key(DictConfig, 'y'))
      >
      > class MyApp:
      >
      >   @byoc.configs
      >   def iter_configs(self):
      >       yield DictConfig({'x': 1, 'y': 2})
      >
      >   x = byoc.param(Key(DictConfig, 'x'))
      >   child = byoc.param(
      >       Value(MyChild()),
      >       on_load=byoc.recursive_load,
      >   )
    expected:
      x: 1
      child.y: 2
  -
    id: recursive-dependencies-in-order
    app:
      > class MyChild:
      >
      >   def __init__(self, parent):
      >       self.parent = parent
      >
      >   def calc_y(self):
      >       return self.parent.x + 1
      >
      >   y = byoc.param(Method(calc_y))
      >
      > class MyApp:
      >
      >   def make_child(self):
      >       return MyChild(self)
      >
      >   x = byoc.param(Value(1))
      >   child = byoc.param(
      >       Method(make_child),
      >       on_load=byoc.recursive_load,
      >   )
    expected:
      x: 1
      child.y: 2
  -
    id: recursive-dependencies-out-of-order-1
    app:
      > class MyChild:
      >   y = byoc.param(Value(2))
      >
      > class MyApp:
      >
      >   def calc_x(self):
      >       return self.child.y - 1
      >
      >   x = byoc.param(Method(calc_x))
      >   child = byoc.param(
      >       Value(MyChild()),
      >       on_load=byoc.recursive_load,
      >   )
    expected:
      x: 1
      child.y: 2
  -
    id: recursive-dependencies-out-of-order-2
    app:
      # Initially, the queue will be [`child`, `x`].  When `child` is loaded, 
      # it will come off the queue and `child.y` will be added to the bottom, 
      # so the queue will be [`x`, `child.y`].  Note that `x` is still before 
      # `child.y`, even though it was after `child`.
      > class MyChild:
      >   y = byoc.param(Value(2))
      >
      > class MyApp:
      >
      >   def calc_x(self):
      >       return self.child.y - 1
      >
      >   child = byoc.param(
      >       Value(MyChild()),
      >       on_load=byoc.recursive_load,
      >   )
      >   x = byoc.param(Method(calc_x))
    expected:
      x: 1
      child.y: 2
  -
    id: recursive-dependencies-circular
    app:
      > class MyChild:

      >   def __init__(self, parent):
      >       self.parent = parent
      >
      >   def calc_y(self):
      >       return self.parent.x + 1
      >
      >   y = byoc.param(Method(calc_y))
      >
      > class MyApp:
      >
      >   def calc_x(self):
      >       return self.child.y - 1
      >   
      >   def make_child(self):
      >       return MyChild(self)
      >
      >   x = byoc.param(Method(calc_x))
      >   child = byoc.param(
      >       Method(make_child),
      >       on_load=byoc.recursive_load,
      >   )
    error:
      type: UsageError
  -
    id: temp-value
    app:
      > class MyConfig(byoc.Config):
      >
      >   def __init__(self, get_x):
      >       self.get_x = get_x
      >
      >   def load(self):
      >       self.finder = byoc.DictFinder({'x': self.get_x()})
      >
      >   def iter_finders(self):
      >       yield self.finder
      >       
      > class MyApp:
      >
      >   @byoc.configs
      >   def iter_configs(self):
      >       yield MyConfig(lambda: self.x + 1)
      >
      >   x = byoc.param(
      >       Key(MyConfig, 'x'),
      >       Value(1),
      >   )

    expected:
      x: 2
  -
    id: temp-value-dependency
    app:
      > class MyConfig(byoc.Config):
      >
      >   def __init__(self, get_x):
      >       self.get_x = get_x
      >
      >   def load(self):
      >       self.finder = byoc.DictFinder({'x': self.get_x()})
      >
      >   def iter_finders(self):
      >       yield self.finder
      >       
      > class MyApp:
      >
      >   @byoc.configs
      >   def iter_configs(self):
      >       yield MyConfig(lambda: self.x + 1)
      >
      >   x = byoc.param(
      >       Key(MyConfig, 'x'),
      >       Method(lambda self: self.y + 1),
      >   )
      >   y = byoc.param(Value(1))

    expected:
      x: 3
  -
    id: temp-value-recursive
    app:
      > class MyConfig(byoc.Config):
      >
      >   def __init__(self, get_x):
      >       self.get_x = get_x
      >
      >   def load(self):
      >       self.finder = byoc.DictFinder({'x': self.get_x()})
      >
      >   def iter_finders(self):
      >       yield self.finder
      >
      > class MyChild:
      >   x = byoc.param(
      >       Key(MyConfig, 'x'),
      >       Value(1),
      >   )
      >       
      > class MyApp:
      >
      >   @byoc.configs
      >   def iter_configs(self):
      >       yield MyConfig(lambda: self.child.x + 1)
      >
      >   child = byoc.param(
      >       Value(MyChild()),
      >       on_load=byoc.recursive_load,
      >   )

    expected:
      child.x: 2
  -
    id: err-duplicate-attr
    app:
      > class MyChild:
      >   x = byoc.param(Value(1))
      >
      > class MyApp:
      >   children = byoc.param(
      >       Value(2 * [MyChild()]),
      >       on_load=byoc.recursive_load_from_list,
      >   )
    error:
      type: UsageError
      message:
        - cannot load the same attribute twice
        - app: <MyChild
        - param: <param MyChild.x>
  -
    id: err-duplicate-meta
    app:
      > class MyApp:
      >
      >   @byoc.meta
      >   def get_meta_1(self):
      >       pass
      >
      >   @byoc.meta
      >   def get_meta_2(self):
      >       pass
    error:
      type: UsageError
      message:
        - cannot mark more than one method with `@byoc.meta`
        - get_meta_1
        - get_meta_2
  -
    id: err-duplicate-meta-inheritance
    app:
      > class MyParent:
      >
      >   @byoc.meta
      >   def get_meta_1(self):
      >       pass
      >
      > class MyApp(MyParent):
      >
      >   @byoc.meta
      >   def get_meta_2(self):
      >       pass
    error:
      type: UsageError
      message:
        - cannot mark more than one method with `@byoc.meta`
        - get_meta_1
        - get_meta_2

test_load_collection:
  -
    id: list
    app: 
      - byoc.param(Value(1))
      - 2
    expected:
      app:
        [1,2]
  -
    id: list-list
    app: 
      - byoc.param(Value(1))
      - 2
      - 
        - byoc.param(Value(3))
        - 4
    expected:
      app:
        [1, 2, [3, 4]]
  -
    id: list-dict
    app: 
      - byoc.param(Value(1))
      - 2
      -
        x: byoc.param(Value(3))
        y: 4
    expected:
      app:
        [1, 2, {x: 3, y: 4}]
  -
    id: dict
    app: 
      x: byoc.param(Value(1))
      y: 2
    expected:
      app:
        {x: 1, y: 2}
  -
    id: dict-dict
    app: 
      x: byoc.param(Value(1))
      y: 2
      z:
        a: byoc.param(Value(3))
        b: 4
    expected:
      app:
        {x: 1, y: 2, z: {a: 3, b: 4}}
  -
    id: dict-list
    app:
      x: byoc.param(Value(1))
      y: 2
      z: 
        - byoc.param(Value(3))
        - 4
    expected:
      app:
        {x: 1, y: 2, z: [3, 4]}
  -
    id: configs
    app: 
      - byoc.param(Key(DictConfig, 'x'))
      - byoc.param(Key(DictConfig, 'y'))
    configs:
      - DictConfig({'x': 1, 'y': 2})
    expected:
      app:
        [1, 2]
  -
    id: meta
    app: 
      # Explicitly use a multiline string, so that we get real line numbers.
      > dict(
      >     x=byoc.param(Value(1)),
      >     y=[
      >         byoc.param(Value(2)),
      >         byoc.param(Value(3)),
      >         4,
      >     ],
      >     z=5,
      > )
    meta:
      x: None
      y: [None, None, None]
      z: None
    expected:
      app:
        {x: 1, y: [2, 3, 4], z: 5}
      meta:
        x: byoc.PythonMeta('<string>', 2)
        y:
          - byoc.PythonMeta('<string>', 4)
          - byoc.PythonMeta('<string>', 5)
          - None
        z: None
  -
    id: meta-from-collection
    app: 
      # Explicitly use a multiline string, so that we get real line numbers.
      > dict(
      >     x=byoc.param(Value(1)),
      >     y=[
      >         byoc.param(Value(2)),
      >         byoc.param(Value(3)),
      >         4,
      >     ],
      >     z=5,
      > )
    meta: byoc.meta_from_collection(app)
    expected:
      app:
        {x: 1, y: [2, 3, 4], z: 5}
      meta:
        x: byoc.PythonMeta('<string>', 2)
        y:
          - byoc.PythonMeta('<string>', 4)
          - byoc.PythonMeta('<string>', 5)
          - None
        z: None
  -
    id: getitem
    app: 
      x: 1
      y: byoc.param(Method(lambda self: byoc.getitem(self, 'x') + 1))
    expected:
      app:
        x: 1
        y: 2
  -
    id: err-not-list-or-dict
    app: byoc.param(Value(1))
    error:
      type: UsageError
